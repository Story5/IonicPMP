# 一、算法图解

## 1.大O表示法

* **大O表示法让你能够比较操作数，它指出了算法运行时间的增速**。

* **大O表示法指出了最糟情况下的运行时间**

## 2.常见5种大O运行时间

下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。

- *O*(log *n*)，也叫**对数时间**，这样的算法包括**二分查找**。
- *O*(*n*)，也叫**线性时间**，这样的算法包括**简单查找**。
- *O*(*n* * log *n*)，这样的算法包括**快速排序**,**归并排序**
- *O*(*n*2)，这样的算法包括**选择排序**——一种速度较慢的排序算法。
- *O*(*n*!)，这样的算法包括**旅行商问题**的解决方案——一种非常慢的算法。

![常见5种大O](http://www.ituring.com.cn/figures/2017/CalPic/09.d04z.037.png)

## 3.常见数组和链表运行时间

![数组和链表运行时间](http://www.ituring.com.cn/figures/2017/CalPic/07.d02z.018.png)

## 4.递归

* **每个递归函数都有两部分：基线条件**（base case）**和递归条件**（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。

- 所有函数调用都进入调用栈。
- 调用栈可能很长，这将占用大量的内存。

## 5.hash表(字典)

### (1)hash表性能

![hash表性能](http://www.ituring.com.cn/figures/2017/CalPic/10.d05z.045.png)

### (2)常量时间

在hash表中查找所花费的时间为常量时间。

![hash表常量时间](http://www.ituring.com.cn/figures/2017/CalPic/10.d05z.044.png)

### (3)如何避免冲突

* 较低的填装因子；
* 良好的散列函数。

> 一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。

## 6.广度优先搜索(图算法)

### (1)定义

解决**最短路径问题**的算法被称为**广度优先搜索**

### (2)实现

* 数据结构: hash

* 队列(先进先出)

### (3)运行时间

广度优先搜索的运行时间为*O*(*V* + *E*)，其中*V* 为顶点（vertice）数，*E* 为边数。

## 7.狄克斯特拉算法

### (1)术语

* 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为**权重**（weight）。

* 带权重的图称为**加权图**，不带权重的图称为**非加权图**。
* 狄克斯特拉算法只适用于**有向无环图**
* **不能将狄克斯特拉算法用于包含负权边的图**

### (2)算法步骤

狄克斯特拉算法包含4个步骤。

(1) 找出最便宜的节点，即可在最短时间内前往的节点。

(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。

(3) 重复这个过程，直到对图中的每个节点都这样做了。

(4) 计算最终路径。

## 8.贪婪算法

## 9.动态规划

> 每种动态规划解决方案都涉及网格。

### (1)背包问题

![网格](http://www.ituring.com.cn/figures/2017/CalPic/14.d09z.024.png)

![公式](http://www.ituring.com.cn/figures/2017/CalPic/14.d09z.025.png)

## 10.K最近邻算法

- 分类就是编组；
- 回归就是预测结果（如一个数字）。

## 11.常用算法名词

### (1)**反向索引**

搜索引擎

### (2)傅里叶变换

* MP3
* jpg

### (3)MapReduce分布式算法

分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：

* 映射（`map`）函数
* 归并（`reduce`）函数。

### (4)SHA算法

散列函数接受一个字符串，并返回一个索引号。

### (5)线性规划

* 线性规划用于在给定约束条件下最大限度地改善指定的指标。

* 线性规划使用Simplex算法

# 二、算法面试通关40讲

